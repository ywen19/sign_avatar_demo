<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sign Avatar Viewer</title>
  <style>
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }
  </style>
</head>
<body>

<script src="three.min.js"></script>
<script src="GLTFLoader.js"></script>

<script>
  console.log("DEBUG INDEX VERSION = 20250212_FULL");   // ← 每次我都会更新这个，用来验证你加载的是最新文件

  //-----------------------------
  // 全局 JS 错误捕获（非常重要）
  //-----------------------------
  window.addEventListener("error", function (e) {
    console.error("Global JS error:", e.message, "@", e.filename + ":" + e.lineno);
  });
  window.addEventListener("unhandledrejection", function (e) {
    console.error("Unhandled promise rejection:", e.reason);
  });

  console.log("Page loaded. href =", window.location.href);
  console.log("THREE version:", THREE.REVISION);

  if (!THREE.GLTFLoader) console.error("GLTFLoader NOT detected!");
  else console.log("GLTFLoader detected.");

  //--------------------------------------
  // Scene / Camera / Renderer
  //--------------------------------------
  let scene, camera, renderer, avatar;

  // 动画 & 骨骼数据
  let skeleton = null;
  const boneNameMap = {};

  let animData = null;
  let poseFrames = {};
  let maxFrame = 0;
  let fps = 30;

  const clock = new THREE.Clock();

  // 归一化骨骼名：mixamorigHips → Hips
  function normalizeBoneName(name) {
    if (!name) return name;
    return name.replace(/^mixamorig[:_]?/i, "");
  }

  //--------------------------------------
  // 初始化场景
  //--------------------------------------
  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);

    camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 1.6, 3);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // 环境光 + 方向光
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    scene.add(hemi);

    const dirLight = new THREE.DirectionalLight(0xffffff, 2);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    window.addEventListener("resize", onWindowResize);
  }

  //--------------------------------------
  // 加载 GLB 模型
  //--------------------------------------
  function loadModel() {
    const url = "model.glb";
    console.log("Trying to load model from:", url);

    const loader = new THREE.GLTFLoader();

    loader.load(
      url,
      function (gltf) {
        avatar = gltf.scene;

        avatar.scale.set(100, 100, 100);
        scene.add(avatar);

        // center model
        const bbox = new THREE.Box3().setFromObject(avatar);
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        bbox.getSize(size);
        bbox.getCenter(center);

        console.log("Model bbox size:", size);
        console.log("Model bbox center:", center);

        avatar.position.sub(center);

        const targetY = 8.0;
        const distance = 23.0;

        camera.position.set(0, targetY, distance);
        camera.lookAt(0, targetY, 0);

        console.log("GLB loaded successfully.");

        // 寻找 skeleton
        avatar.traverse((obj) => {
          if (obj.isSkinnedMesh && !skeleton) {
            skeleton = obj.skeleton;
          }
        });

        if (!skeleton) {
          console.warn("No skeleton found!");
        } else {
          skeleton.bones.forEach((bone) => {
            const key = normalizeBoneName(bone.name);
            boneNameMap[key] = bone;
          });
          console.log("Skeleton bones normalized:", Object.keys(boneNameMap));
        }
      },
      undefined,
      function (err) {
        console.error("GLB load failed:", err);
      }
    );
  }

  //--------------------------------------
  // 加载 JSON 动画
  //--------------------------------------
  function loadAnimation() {
    console.log("loadAnimation() CALLED");

    const jsonUrl = "Dancing_mixamo_com_frames.json";
    console.log("Loading JSON animation from:", jsonUrl);

    fetch(jsonUrl)
      .then(res => {
        console.log("JSON fetch status =", res.status);
        if (!res.ok) throw new Error("HTTP " + res.status);
        return res.json();
      })
      .then(data => {
        console.log("JSON animation loaded OK.");
        animData = data;
        fps = data.fps || fps;
        preparePoseFrames(data);
      })
      .catch(err => {
        console.error("Load JSON animation failed:", err);
      });
  }

  //--------------------------------------
  // 预处理 JSON 动画（按帧存储四元数）
  //--------------------------------------
  function preparePoseFrames(data) {
    poseFrames = {};
    maxFrame = 0;

    for (const name in data.bones) {
      const arr = [];
      const keyframes = data.bones[name];

      keyframes.forEach(k => {
        arr[k.f] = new THREE.Quaternion(
          k.rot[0],
          k.rot[1],
          k.rot[2],
          k.rot[3]
        );
        if (k.f > maxFrame) maxFrame = k.f;
      });

      const norm = normalizeBoneName(name);
      poseFrames[norm] = arr;
    }

    console.log("Prepared JSON animation. fps =", fps, "maxFrame =", maxFrame);
  }

  //--------------------------------------
  // 动画更新
  //--------------------------------------
  function updateAnimation(dt) {
    if (!avatar || !animData || !skeleton) return;

    if (updateAnimation.time === undefined) updateAnimation.time = 0;
    updateAnimation.time += dt;

    const totalFrames = maxFrame + 1;
    const currentFrame = Math.floor((updateAnimation.time * fps) % totalFrames);

    for (const name in poseFrames) {
      const bone = boneNameMap[name];
      if (!bone) continue;

      const q = poseFrames[name][currentFrame];
      if (!q) continue;

      bone.quaternion.copy(q);
    }

    avatar.updateMatrixWorld(true);
  }

  //--------------------------------------
  // render loop
  //--------------------------------------
  function animate() {
    requestAnimationFrame(animate);

    const dt = clock.getDelta();

    // ==== 新增：统计实际渲染 FPS（Qt UI 里真实帧率）====
    if (!animate._frameCount) {
      animate._frameCount = 0;
      animate._timeAccum = 0;
    }
    animate._frameCount++;
    animate._timeAccum += dt;

    // 每 30 帧统计一次平均 FPS，避免刷屏
    if (animate._frameCount >= 30) {
      const avgFps = (animate._frameCount / animate._timeAccum).toFixed(1);
      console.log("Qt UI Render FPS (avg):", avgFps);
      animate._frameCount = 0;
      animate._timeAccum = 0;
    }
    // ==================================================

    updateAnimation(dt);
    renderer.render(scene, camera);
  }


  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  //--------------------------------------
  // RUN
  //--------------------------------------
  init();
  loadModel();
  loadAnimation();
  animate();
</script>

</body>
</html>
